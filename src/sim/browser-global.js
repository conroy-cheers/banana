/* auto-generated by scripts/build-browser-global.js */
(function () {
const DEFAULTS = {
  maxParticles: 8000,
  fixedDt: 1 / 60,
  gravity: 1900,
  velocityDamping: 0.9958,
  airSpin: 0.005,
  restitution: 0.1,
  floorFriction: 0.92,
  collisionPasses: 2,
  spawnRateMax: 150,
  spawnRateMin: 7,
  densityFactor: 6.9,
  mouseRadius: 130,
  mousePush: 135,
  mouseWakeRadiusMul: 1.08,
  wakeCursorRadiusMul: 1.85,
  planeSizeScale: [0.9, 0.915, 0.93, 0.945, 0.96, 0.975, 0.99, 1],
  planeAlpha: [0.72, 0.76, 0.8, 0.84, 0.88, 0.92, 0.95, 0.98],
  planeMouseInfluence: [0.72, 0.76, 0.8, 0.84, 0.88, 0.92, 0.96, 1],
  planeSpawnWeight: [0.1486, 0.1419, 0.1351, 0.1284, 0.1216, 0.1149, 0.1081, 0.1014],
  planeGravityScale: [0.95, 0.958, 0.966, 0.974, 0.982, 0.99, 0.996, 1],
  planeBaseTarget: [2200, 2100, 2000, 1900, 1800, 1700, 1600, 1500],
  baseDensityReference: 6.9,
  colliderScale: 0.5,
  contactSlop: 0.09,
  positionCorrection: 0.22,
  normalImpulseEps: 0.06,
  contactTangentDamp: 0.2,
  contactVelCutoff: 0.03,
  segmentEps: 0.000001,
  collisionSpinFactor: 0.0002,
  floorSleepVy: 0.55,
  floorSleepVx: 0.28,
  floorSleepSpin: 0.0015,
  interiorSleepFrames: 16,
  interiorSleepSpeed: 0.02,
  interiorSleepSpin: 0.0006,
  wakeImpulse: 0.9,
  wakeOverlapRatio: 0.22,
  fluidThreshold: 0.58,
  fluidUpdateInterval: 1,
};

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function computeFluidCellSize(radiusBase, radiusVar, planeSizeScale) {
  let weightedScale = 0;
  for (let i = 0; i < planeSizeScale.length; i++) weightedScale += planeSizeScale[i];
  weightedScale /= planeSizeScale.length;
  const avgRadius = (radiusBase + radiusVar * 0.5) * weightedScale;
  return clamp(Math.floor(avgRadius * 2.8), 20, 64);
}



function createMulberry32(seed) {
  let t = seed >>> 0;
  return function rand() {
    t += 0x6d2b79f5;
    let x = Math.imul(t ^ (t >>> 15), 1 | t);
    x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
  };
}

class BananaPileEngine {
  constructor(options = {}) {
    this.maxParticles = options.maxParticles ?? DEFAULTS.maxParticles;
    this.fixedDt = options.fixedDt ?? DEFAULTS.fixedDt;

    this.gravity = options.gravity ?? DEFAULTS.gravity;
    this.velocityDamping = options.velocityDamping ?? DEFAULTS.velocityDamping;
    this.airSpin = options.airSpin ?? DEFAULTS.airSpin;
    this.restitution = options.restitution ?? DEFAULTS.restitution;
    this.floorFriction = options.floorFriction ?? DEFAULTS.floorFriction;
    this.collisionPasses = options.collisionPasses ?? DEFAULTS.collisionPasses;

    this.spawnRateMax = options.spawnRateMax ?? DEFAULTS.spawnRateMax;
    this.spawnRateMin = options.spawnRateMin ?? DEFAULTS.spawnRateMin;
    this.densityFactor = options.densityFactor ?? DEFAULTS.densityFactor;

    this.mouseRadius = options.mouseRadius ?? DEFAULTS.mouseRadius;
    this.mousePush = options.mousePush ?? DEFAULTS.mousePush;
    this.mouseRadiusSq = this.mouseRadius * this.mouseRadius;

    this.mouseWakeRadiusMul = options.mouseWakeRadiusMul ?? DEFAULTS.mouseWakeRadiusMul;
    this.wakeCursorRadiusMul = options.wakeCursorRadiusMul ?? DEFAULTS.wakeCursorRadiusMul;

    this.contactSlop = options.contactSlop ?? DEFAULTS.contactSlop;
    this.positionCorrection = options.positionCorrection ?? DEFAULTS.positionCorrection;
    this.normalImpulseEps = options.normalImpulseEps ?? DEFAULTS.normalImpulseEps;
    this.contactTangentDamp = options.contactTangentDamp ?? DEFAULTS.contactTangentDamp;
    this.contactVelCutoff = options.contactVelCutoff ?? DEFAULTS.contactVelCutoff;
    this.segmentEps = options.segmentEps ?? DEFAULTS.segmentEps;
    this.collisionSpinFactor = options.collisionSpinFactor ?? DEFAULTS.collisionSpinFactor;

    this.floorSleepVy = options.floorSleepVy ?? DEFAULTS.floorSleepVy;
    this.floorSleepVx = options.floorSleepVx ?? DEFAULTS.floorSleepVx;
    this.floorSleepSpin = options.floorSleepSpin ?? DEFAULTS.floorSleepSpin;

    this.interiorSleepFrames = options.interiorSleepFrames ?? DEFAULTS.interiorSleepFrames;
    this.interiorSleepSpeed = options.interiorSleepSpeed ?? DEFAULTS.interiorSleepSpeed;
    this.interiorSleepSpeedSq = this.interiorSleepSpeed * this.interiorSleepSpeed;
    this.interiorSleepSpin = options.interiorSleepSpin ?? DEFAULTS.interiorSleepSpin;
    this.wakeImpulse = options.wakeImpulse ?? DEFAULTS.wakeImpulse;
    this.wakeOverlapRatio = options.wakeOverlapRatio ?? DEFAULTS.wakeOverlapRatio;
    this.fluidUpdateInterval = Math.max(
      1,
      options.fluidUpdateInterval ?? DEFAULTS.fluidUpdateInterval
    );

    this.fluidThreshold = options.fluidThreshold ?? DEFAULTS.fluidThreshold;

    this.planeSizeScale = Float32Array.from(options.planeSizeScale ?? DEFAULTS.planeSizeScale);
    this.planeAlpha = Float32Array.from(options.planeAlpha ?? DEFAULTS.planeAlpha);
    this.planeMouseInfluence = Float32Array.from(
      options.planeMouseInfluence ?? DEFAULTS.planeMouseInfluence
    );
    this.planeSpawnWeight = Float32Array.from(options.planeSpawnWeight ?? DEFAULTS.planeSpawnWeight);
    this.planeGravityScale = Float32Array.from(options.planeGravityScale ?? DEFAULTS.planeGravityScale);
    this.planeBaseTarget = Int32Array.from(options.planeBaseTarget ?? DEFAULTS.planeBaseTarget);
    this.planeCount = this.planeBaseTarget.length;
    this.baseDensityReference = options.baseDensityReference ?? DEFAULTS.baseDensityReference;

    const fitPlaneValues = (values, fallback) => {
      const out = new Float32Array(this.planeCount);
      const last = values.length > 0 ? values[values.length - 1] : fallback;
      for (let p = 0; p < this.planeCount; p++) {
        const raw = p < values.length ? values[p] : last;
        out[p] = Number.isFinite(raw) ? raw : fallback;
      }
      return out;
    };
    this.planeSizeScale = fitPlaneValues(this.planeSizeScale, 1);
    this.planeAlpha = fitPlaneValues(this.planeAlpha, 1);
    this.planeMouseInfluence = fitPlaneValues(this.planeMouseInfluence, 1);
    this.planeGravityScale = fitPlaneValues(this.planeGravityScale, 1);

    const spawnWeights = fitPlaneValues(this.planeSpawnWeight, 1);
    let spawnWeightSum = 0;
    for (let p = 0; p < this.planeCount; p++) {
      spawnWeights[p] = Math.max(0, spawnWeights[p]);
      spawnWeightSum += spawnWeights[p];
    }
    if (spawnWeightSum <= 0) {
      const uniformWeight = 1 / Math.max(1, this.planeCount);
      spawnWeights.fill(uniformWeight);
    } else {
      for (let p = 0; p < this.planeCount; p++) {
        spawnWeights[p] /= spawnWeightSum;
      }
    }
    this.planeSpawnWeight = spawnWeights;

    this.colliderScale = options.colliderScale ?? DEFAULTS.colliderScale;
    this.capRadiusFactor = 0.62 * this.colliderScale;
    this.capHalfFactor = 1.38 * this.colliderScale;
    this.capBoundFactor = this.capRadiusFactor + this.capHalfFactor;

    this.width = 1;
    this.height = 1;

    this.seed = options.seed ?? 1337;
    this.rand = createMulberry32(this.seed);

    this.particleCount = 0;
    this.targetCount = 0;

    this.planeTarget = new Int32Array(this.planeCount);
    this.planePopulation = new Int32Array(this.planeCount);
    this.spawnAccumulator = new Float64Array(this.planeCount);

    this.px = new Float32Array(this.maxParticles);
    this.py = new Float32Array(this.maxParticles);
    this.x = new Float32Array(this.maxParticles);
    this.y = new Float32Array(this.maxParticles);
    this.r = new Float32Array(this.maxParticles);
    this.capR = new Float32Array(this.maxParticles);
    this.capHalf = new Float32Array(this.maxParticles);
    this.capBound = new Float32Array(this.maxParticles);
    this.depth = new Float32Array(this.maxParticles);
    this.plane = new Uint8Array(this.maxParticles);
    this.rot = new Float32Array(this.maxParticles);
    this.dirX = new Float32Array(this.maxParticles);
    this.dirY = new Float32Array(this.maxParticles);
    this.axialCos = new Float32Array(this.maxParticles);
    this.axialSin = new Float32Array(this.maxParticles);
    this.vrot = new Float32Array(this.maxParticles);
    this.tint = new Float32Array(this.maxParticles);

    this.cellX = new Int16Array(this.maxParticles);
    this.cellY = new Int16Array(this.maxParticles);
    this.nextInCell = new Int32Array(this.maxParticles);

    this.sleeping = new Uint8Array(this.maxParticles);
    this.sleepCounter = new Uint16Array(this.maxParticles);
    this.region = new Uint8Array(this.maxParticles);
    this.fluidCellOfParticle = new Int32Array(this.maxParticles);

    this.sleepingCount = 0;
    this.boundaryAwakeCount = 0;
    this.interiorSleepingCount = 0;

    this.collisionCellSize = 26;
    this.collisionCols = 1;
    this.collisionRows = 1;
    this.collisionGridHead = new Int32Array(1);
    this.neighborRange = 1;

    this.fluidCellSize = 32;
    this.fluidCols = 1;
    this.fluidRows = 1;
    this.fluidOcc = new Float32Array(1);
    this.fluidMask = new Uint8Array(1);
    this.boundaryMask = new Uint8Array(1);
    this.activeIndices = new Int32Array(this.maxParticles);
    this.activeCount = 0;
    this.stepIndex = 0;

    this.mouse = {
      active: false,
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
    };

    this.resize(options.width ?? 960, options.height ?? 540);
  }

  reseed(seed) {
    this.seed = seed >>> 0;
    this.rand = createMulberry32(this.seed);
  }

  resize(width, height) {
    this.width = Math.max(1, Math.floor(width));
    this.height = Math.max(1, Math.floor(height));

    const minDim = Math.min(this.width, this.height);
    this.radiusBase = clamp(minDim * 0.0195, 20, 45);
    this.radiusVar = this.radiusBase * 0.68;

    const collisionMaxBound = (this.radiusBase + this.radiusVar) * this.capBoundFactor;
    this.collisionCellSize = Math.max(22, Math.floor((this.radiusBase + this.radiusVar) * 2.2));
    this.neighborRange = Math.max(1, Math.ceil((collisionMaxBound * 2) / this.collisionCellSize));
    this.collisionCols = Math.max(1, Math.ceil(this.width / this.collisionCellSize) + 2);
    this.collisionRows = Math.max(1, Math.ceil(this.height / this.collisionCellSize) + 4);
    this.collisionGridHead = new Int32Array(this.collisionCols * this.collisionRows);

    this.fluidCellSize = computeFluidCellSize(this.radiusBase, this.radiusVar, this.planeSizeScale);
    this.fluidCols = Math.max(1, Math.ceil(this.width / this.fluidCellSize) + 2);
    this.fluidRows = Math.max(1, Math.ceil(this.height / this.fluidCellSize) + 4);
    const fluidCellCount = this.fluidCols * this.fluidRows;
    this.fluidOcc = new Float32Array(fluidCellCount);
    this.fluidMask = new Uint8Array(fluidCellCount);
    this.boundaryMask = new Uint8Array(fluidCellCount);

    this.refreshTargetCount();
  }

  refreshTargetCount() {
    const densityScale = this.baseDensityReference / Math.max(3.2, this.densityFactor);
    let sum = 0;
    for (let p = 0; p < this.planeCount; p++) {
      const count = Math.floor(this.planeBaseTarget[p] * densityScale);
      this.planeTarget[p] = Math.max(0, count);
      sum += this.planeTarget[p];
    }

    if (sum > this.maxParticles) {
      const scale = this.maxParticles / sum;
      sum = 0;
      for (let p = 0; p < this.planeCount; p++) {
        this.planeTarget[p] = Math.floor(this.planeTarget[p] * scale);
        sum += this.planeTarget[p];
      }
    }

    this.targetCount = sum;
  }

  setDensityFactor(value) {
    this.densityFactor = value;
    this.refreshTargetCount();
  }

  setTuning(values = {}) {
    if (values.gravity != null) this.gravity = values.gravity;
    if (values.restitution != null) this.restitution = values.restitution;
    if (values.floorFriction != null) this.floorFriction = values.floorFriction;
    if (values.collisionPasses != null) this.collisionPasses = Math.max(1, Math.floor(values.collisionPasses));
    if (values.spawnRateMax != null) this.spawnRateMax = values.spawnRateMax;
    if (values.spawnRateMin != null) this.spawnRateMin = values.spawnRateMin;
    if (values.mouseRadius != null) {
      this.mouseRadius = values.mouseRadius;
      this.mouseRadiusSq = this.mouseRadius * this.mouseRadius;
    }
    if (values.mousePush != null) this.mousePush = values.mousePush;
    if (values.densityFactor != null) this.setDensityFactor(values.densityFactor);
    if (values.interiorSleepFrames != null) this.interiorSleepFrames = Math.max(1, Math.floor(values.interiorSleepFrames));
    if (values.interiorSleepSpeed != null) {
      this.interiorSleepSpeed = Math.max(0.0001, values.interiorSleepSpeed);
      this.interiorSleepSpeedSq = this.interiorSleepSpeed * this.interiorSleepSpeed;
    }
    if (values.interiorSleepSpin != null) this.interiorSleepSpin = Math.max(0, values.interiorSleepSpin);
    if (values.fluidThreshold != null) this.fluidThreshold = clamp(values.fluidThreshold, 0.1, 2.5);
    if (values.fluidUpdateInterval != null) {
      this.fluidUpdateInterval = Math.max(1, Math.floor(values.fluidUpdateInterval));
    }
  }

  getTuning() {
    return {
      gravity: this.gravity,
      restitution: this.restitution,
      floorFriction: this.floorFriction,
      collisionPasses: this.collisionPasses,
      spawnRateMax: this.spawnRateMax,
      spawnRateMin: this.spawnRateMin,
      mouseRadius: this.mouseRadius,
      mousePush: this.mousePush,
      densityFactor: this.densityFactor,
      interiorSleepFrames: this.interiorSleepFrames,
      interiorSleepSpeed: this.interiorSleepSpeed,
      interiorSleepSpin: this.interiorSleepSpin,
      fluidThreshold: this.fluidThreshold,
      fluidUpdateInterval: this.fluidUpdateInterval,
    };
  }

  resetPile() {
    this.particleCount = 0;
    this.planePopulation.fill(0);
    this.spawnAccumulator.fill(0);
    this.sleeping.fill(0);
    this.sleepCounter.fill(0);
    this.region.fill(0);
    this.fluidCellOfParticle.fill(0);
    this.sleepingCount = 0;
    this.boundaryAwakeCount = 0;
    this.interiorSleepingCount = 0;
    this.activeCount = 0;
    this.stepIndex = 0;
    this.clearMouse();
  }

  setMouse(x, y, vx = 0, vy = 0, active = true) {
    this.mouse.active = active;
    this.mouse.x = x;
    this.mouse.y = y;
    this.mouse.vx = vx;
    this.mouse.vy = vy;
  }

  clearMouse() {
    this.mouse.active = false;
    this.mouse.vx = 0;
    this.mouse.vy = 0;
  }

  spawnOne(p) {
    if (
      this.particleCount >= this.targetCount ||
      this.particleCount >= this.maxParticles ||
      this.planePopulation[p] >= this.planeTarget[p]
    ) {
      return false;
    }

    const i = this.particleCount++;
    const dz = this.rand();
    const radius = (this.radiusBase + dz * this.radiusVar) * this.planeSizeScale[p];

    const sx = this.rand() * this.width;
    const sy = -radius - this.rand() * (70 + (this.planeCount - 1 - p) * 18);
    const vx = (this.rand() - 0.5) * 110;
    const vy = this.rand() * 70;

    this.x[i] = sx;
    this.y[i] = sy;
    this.px[i] = sx - vx * this.fixedDt;
    this.py[i] = sy - vy * this.fixedDt;

    this.r[i] = radius;
    this.capR[i] = radius * this.capRadiusFactor;
    this.capHalf[i] = radius * this.capHalfFactor;
    this.capBound[i] = this.capR[i] + this.capHalf[i];
    this.plane[i] = p;
    const planeDepthStep = 0.12 / Math.max(1, this.planeCount - 1);
    this.depth[i] = dz * 0.9 + p * planeDepthStep;
    this.rot[i] = this.rand() * Math.PI * 2;
    this.dirX[i] = Math.cos(this.rot[i]);
    this.dirY[i] = Math.sin(this.rot[i]);
    const axial = this.rand() * Math.PI * 2;
    this.axialCos[i] = Math.cos(axial);
    this.axialSin[i] = Math.sin(axial);
    this.vrot[i] = (this.rand() - 0.5) * 0.06;
    this.tint[i] = 0.9 + this.rand() * 0.18;

    this.sleeping[i] = 0;
    this.sleepCounter[i] = 0;
    this.region[i] = 0;

    this.planePopulation[p]++;
    return true;
  }

  spawnStep(dt = this.fixedDt) {
    if (this.particleCount >= this.targetCount) return;

    const fill = this.particleCount / Math.max(1, this.targetCount);
    const eased = Math.max(0, 1 - Math.pow(fill, 0.6));
    const rate = this.spawnRateMin + (this.spawnRateMax - this.spawnRateMin) * eased;

    for (let p = 0; p < this.planeCount; p++) {
      if (this.planePopulation[p] >= this.planeTarget[p]) continue;
      this.spawnAccumulator[p] += rate * this.planeSpawnWeight[p] * dt;
      while (
        this.spawnAccumulator[p] >= 1 &&
        this.particleCount < this.targetCount &&
        this.planePopulation[p] < this.planeTarget[p]
      ) {
        this.spawnAccumulator[p] -= 1;
        if (!this.spawnOne(p)) break;
      }
    }
  }

  wakeParticle(i) {
    this.sleeping[i] = 0;
    this.sleepCounter[i] = 0;
  }

  integrate(dt = this.fixedDt) {
    const dtSq = dt * dt;
    const mx = this.mouse.x;
    const my = this.mouse.y;
    const mvx = this.mouse.vx;
    const mvy = this.mouse.vy;
    const wakeRadius = this.mouseRadius * this.wakeCursorRadiusMul;
    const wakeRadiusSq = wakeRadius * wakeRadius;

    for (let i = 0; i < this.particleCount; i++) {
      const p = this.plane[i];
      const sleeping = this.sleeping[i] === 1;

      if (sleeping && this.mouse.active) {
        const dx = this.x[i] - mx;
        const dy = this.y[i] - my;
        if (dx * dx + dy * dy < wakeRadiusSq) {
          this.wakeParticle(i);
        }
      }

      if (this.sleeping[i]) {
        this.px[i] = this.x[i];
        this.py[i] = this.y[i];
        continue;
      }

      let vx = (this.x[i] - this.px[i]) * this.velocityDamping;
      let vy = (this.y[i] - this.py[i]) * this.velocityDamping;

      if (this.mouse.active) {
        const dx = this.x[i] - mx;
        const dy = this.y[i] - my;
        const d2 = dx * dx + dy * dy;
        if (d2 < wakeRadiusSq) {
          const dist = Math.sqrt(d2) + 0.0001;
          const nx = dx / dist;
          const ny = dy / dist;
          const planeInfluence = this.planeMouseInfluence[p];

          if (d2 < this.mouseRadiusSq * this.mouseWakeRadiusMul) {
            const influence = (1 - dist / this.mouseRadius) * this.mousePush * planeInfluence * 1.35;
            vx += nx * influence * dt;
            vy += ny * influence * dt;
            vx += mvx * 0.13;
            vy += mvy * 0.13;
          } else {
            const influence = (1 - dist / wakeRadius) * this.mousePush * planeInfluence * 0.62;
            vx += nx * influence * dt;
            vy += ny * influence * dt;
            vx += mvx * 0.09;
            vy += mvy * 0.09;
          }
        }
      }

      // Interior particles should dissipate motion quickly to avoid deep-pile churn.
      if (this.region[i] === 2) {
        vx *= 0.86;
        vy *= 0.86;
        if (Math.abs(vx) < 0.02) vx = 0;
        if (Math.abs(vy) < 0.02) vy = 0;
      }

      this.px[i] = this.x[i];
      this.py[i] = this.y[i];

      this.x[i] += vx;
      this.y[i] += vy + this.gravity * this.planeGravityScale[p] * dtSq;

      this.rot[i] += this.vrot[i] + vx * this.airSpin;
      this.vrot[i] *= 0.992;
      this.dirX[i] = Math.cos(this.rot[i]);
      this.dirY[i] = Math.sin(this.rot[i]);
    }
  }

  buildCollisionGrid() {
    this.collisionGridHead.fill(-1);
    const size = this.collisionCellSize;
    for (let i = 0; i < this.particleCount; i++) {
      const cx = Math.max(0, Math.min(this.collisionCols - 1, ((this.x[i] / size) | 0) + 1));
      const cy = Math.max(0, Math.min(this.collisionRows - 1, ((this.y[i] / size) | 0) + 2));
      this.cellX[i] = cx;
      this.cellY[i] = cy;
      const index = cy * this.collisionCols + cx;
      this.nextInCell[i] = this.collisionGridHead[index];
      this.collisionGridHead[index] = i;
    }
  }

  resolveBoundary(i) {
    const cr = this.capR[i];
    const ch = this.capHalf[i];
    const ex = Math.abs(this.dirX[i]) * ch + cr;
    const ey = Math.abs(this.dirY[i]) * ch + cr;

    if (this.x[i] < ex) {
      const vx = this.x[i] - this.px[i];
      this.x[i] = ex;
      let nextVx = -vx * this.restitution;
      if (Math.abs(nextVx) < 0.18) nextVx = 0;
      this.px[i] = this.x[i] - nextVx;
      this.wakeParticle(i);
    } else if (this.x[i] > this.width - ex) {
      const vx = this.x[i] - this.px[i];
      this.x[i] = this.width - ex;
      let nextVx = -vx * this.restitution;
      if (Math.abs(nextVx) < 0.18) nextVx = 0;
      this.px[i] = this.x[i] - nextVx;
      this.wakeParticle(i);
    }

    if (this.y[i] > this.height - ey) {
      const vx = this.x[i] - this.px[i];
      const vy = this.y[i] - this.py[i];
      this.y[i] = this.height - ey;

      let nextVx = vx * this.floorFriction;
      let nextVy = -vy * this.restitution;
      if (Math.abs(nextVy) < this.floorSleepVy) nextVy = 0;
      if (Math.abs(nextVx) < this.floorSleepVx) nextVx = 0;

      this.px[i] = this.x[i] - nextVx;
      this.py[i] = this.y[i] - nextVy;

      if (nextVy === 0 && Math.abs(this.vrot[i]) < this.floorSleepSpin) {
        this.vrot[i] = 0;
      } else {
        this.vrot[i] *= 0.82;
      }
    }
  }

  collectActiveParticles() {
    let activeCount = 0;
    for (let i = 0; i < this.particleCount; i++) {
      if (!this.sleeping[i]) {
        this.activeIndices[activeCount++] = i;
      }
    }
    this.activeCount = activeCount;
  }

  resolvePairMixed(i, j, cdx, cdy, cd2) {
    const minDist = this.capBound[i] + this.capBound[j];
    if (cd2 >= minDist * minDist) return;

    const dist = Math.sqrt(cd2) + 0.0001;
    const nx = cdx / dist;
    const ny = cdy / dist;
    const overlap = minDist - dist;
    if (overlap <= this.contactSlop) return;

    const iSleeping = this.sleeping[i] === 1;
    const jSleeping = this.sleeping[j] === 1;
    let wi = 0.5;
    let wj = 0.5;
    if (iSleeping && !jSleeping) {
      wi = 0.08;
      wj = 0.92;
    } else if (!iSleeping && jSleeping) {
      wi = 0.92;
      wj = 0.08;
    }

    const correction = (overlap - this.contactSlop) * this.positionCorrection;
    const cix = nx * correction * wi;
    const ciy = ny * correction * wi;
    const cjx = nx * correction * wj;
    const cjy = ny * correction * wj;
    this.x[i] -= cix;
    this.y[i] -= ciy;
    this.x[j] += cjx;
    this.y[j] += cjy;

    const vix = this.x[i] - this.px[i];
    const viy = this.y[i] - this.py[i];
    const vjx = this.x[j] - this.px[j];
    const vjy = this.y[j] - this.py[j];
    const relN = (vjx - vix) * nx + (vjy - viy) * ny;

    if (relN < -this.normalImpulseEps) {
      const impulse = -(1 + this.restitution) * relN * 0.5;
      const ivx = vix - nx * impulse;
      const ivy = viy - ny * impulse;
      const jvx = vjx + nx * impulse;
      const jvy = vjy + ny * impulse;

      const awakeDamp = 0.72;

      if (iSleeping) {
        this.px[i] = this.x[i];
        this.py[i] = this.y[i];
      } else {
        this.px[i] = this.x[i] - ivx * awakeDamp;
        this.py[i] = this.y[i] - ivy * awakeDamp;
      }

      if (jSleeping) {
        this.px[j] = this.x[j];
        this.py[j] = this.y[j];
      } else {
        this.px[j] = this.x[j] - jvx * awakeDamp;
        this.py[j] = this.y[j] - jvy * awakeDamp;
      }
    } else {
      const settleDamp = 0.62;
      if (iSleeping) {
        this.px[i] = this.x[i];
        this.py[i] = this.y[i];
      } else {
        this.px[i] = this.x[i] - vix * settleDamp;
        this.py[i] = this.y[i] - viy * settleDamp;
      }
      if (jSleeping) {
        this.px[j] = this.x[j];
        this.py[j] = this.y[j];
      } else {
        this.px[j] = this.x[j] - vjx * settleDamp;
        this.py[j] = this.y[j] - vjy * settleDamp;
      }
    }
  }

  resolvePair(i, j) {
    if (this.plane[i] !== this.plane[j]) return;
    if (this.sleeping[i] && this.sleeping[j]) return;

    const cdx = this.x[j] - this.x[i];
    const cdy = this.y[j] - this.y[i];
    const maxDist = this.capBound[i] + this.capBound[j];
    const cd2 = cdx * cdx + cdy * cdy;
    if (cd2 >= maxDist * maxDist) return;

    if (this.sleeping[i] !== this.sleeping[j]) {
      this.resolvePairMixed(i, j, cdx, cdy, cd2);
      return;
    }

    const ih = this.capHalf[i];
    const jh = this.capHalf[j];

    const a0x = this.x[i] - this.dirX[i] * ih;
    const a0y = this.y[i] - this.dirY[i] * ih;
    const a1x = this.x[i] + this.dirX[i] * ih;
    const a1y = this.y[i] + this.dirY[i] * ih;

    const b0x = this.x[j] - this.dirX[j] * jh;
    const b0y = this.y[j] - this.dirY[j] * jh;
    const b1x = this.x[j] + this.dirX[j] * jh;
    const b1y = this.y[j] + this.dirY[j] * jh;

    const ux = a1x - a0x;
    const uy = a1y - a0y;
    const vx = b1x - b0x;
    const vy = b1y - b0y;
    const wx = a0x - b0x;
    const wy = a0y - b0y;

    const a = ux * ux + uy * uy;
    const b = ux * vx + uy * vy;
    const c = vx * vx + vy * vy;
    const d = ux * wx + uy * wy;
    const e = vx * wx + vy * wy;
    const denom = a * c - b * b;

    let sn;
    let sd = denom;
    let tn;
    let td = denom;

    if (denom < this.segmentEps) {
      sn = 0;
      sd = 1;
      tn = e;
      td = c;
    } else {
      sn = b * e - c * d;
      tn = a * e - b * d;

      if (sn < 0) {
        sn = 0;
        tn = e;
        td = c;
      } else if (sn > sd) {
        sn = sd;
        tn = e + b;
        td = c;
      }
    }

    if (tn < 0) {
      tn = 0;
      if (-d < 0) {
        sn = 0;
      } else if (-d > a) {
        sn = sd;
      } else {
        sn = -d;
        sd = a;
      }
    } else if (tn > td) {
      tn = td;
      if (-d + b < 0) {
        sn = 0;
      } else if (-d + b > a) {
        sn = sd;
      } else {
        sn = -d + b;
        sd = a;
      }
    }

    const sc = Math.abs(sn) < this.segmentEps ? 0 : sn / sd;
    const tc = Math.abs(tn) < this.segmentEps ? 0 : tn / td;

    const pax = a0x + sc * ux;
    const pay = a0y + sc * uy;
    const pbx = b0x + tc * vx;
    const pby = b0y + tc * vy;

    const dx = pbx - pax;
    const dy = pby - pay;
    const minDist = this.capR[i] + this.capR[j];
    const d2 = dx * dx + dy * dy;
    if (d2 >= minDist * minDist) return;

    let dist = Math.sqrt(d2);
    let nx;
    let ny;
    if (dist < 0.0001) {
      const centerDist = Math.sqrt(cd2) + 0.0001;
      nx = cdx / centerDist;
      ny = cdy / centerDist;
      dist = 0;
    } else {
      nx = dx / dist;
      ny = dy / dist;
    }

    const overlap = minDist - dist;
    if (overlap <= this.contactSlop) return;

    let wi = 0.5;
    let wj = 0.5;
    if (this.sleeping[i] && !this.sleeping[j]) {
      wi = 0.08;
      wj = 0.92;
    } else if (!this.sleeping[i] && this.sleeping[j]) {
      wi = 0.92;
      wj = 0.08;
    }

    const correction = (overlap - this.contactSlop) * this.positionCorrection;
    const cix = nx * correction * wi;
    const ciy = ny * correction * wi;
    const cjx = nx * correction * wj;
    const cjy = ny * correction * wj;
    this.x[i] -= cix;
    this.y[i] -= ciy;
    this.x[j] += cjx;
    this.y[j] += cjy;

    if (this.sleeping[i]) {
      this.px[i] -= cix;
      this.py[i] -= ciy;
    }
    if (this.sleeping[j]) {
      this.px[j] += cjx;
      this.py[j] += cjy;
    }

    const vix = this.x[i] - this.px[i];
    const viy = this.y[i] - this.py[i];
    const vjx = this.x[j] - this.px[j];
    const vjy = this.y[j] - this.py[j];
    const relN = (vjx - vix) * nx + (vjy - viy) * ny;
    let ivx = vix;
    let ivy = viy;
    let jvx = vjx;
    let jvy = vjy;

    if (relN < -this.normalImpulseEps) {
      const impulse = -(1 + this.restitution) * relN * 0.5;
      ivx = vix - nx * impulse;
      ivy = viy - ny * impulse;
      jvx = vjx + nx * impulse;
      jvy = vjy + ny * impulse;

      const spin = impulse * this.collisionSpinFactor;
      this.vrot[i] -= spin;
      this.vrot[j] += spin;
    }

    const tx = -ny;
    const ty = nx;
    const relT = (jvx - ivx) * tx + (jvy - ivy) * ty;
    const tImpulse = relT * this.contactTangentDamp;

    ivx += tx * tImpulse;
    ivy += ty * tImpulse;
    jvx -= tx * tImpulse;
    jvy -= ty * tImpulse;

    if (Math.abs(ivx) < this.contactVelCutoff) ivx = 0;
    if (Math.abs(ivy) < this.contactVelCutoff) ivy = 0;
    if (Math.abs(jvx) < this.contactVelCutoff) jvx = 0;
    if (Math.abs(jvy) < this.contactVelCutoff) jvy = 0;

    if (this.sleeping[i]) {
      this.px[i] = this.x[i];
      this.py[i] = this.y[i];
      this.vrot[i] = 0;
    } else {
      this.px[i] = this.x[i] - ivx;
      this.py[i] = this.y[i] - ivy;
    }

    if (this.sleeping[j]) {
      this.px[j] = this.x[j];
      this.py[j] = this.y[j];
      this.vrot[j] = 0;
    } else {
      this.px[j] = this.x[j] - jvx;
      this.py[j] = this.y[j] - jvy;
    }
  }

  capsuleOverlapRatio(i, j) {
    if (this.plane[i] !== this.plane[j]) return 0;

    const cdx = this.x[j] - this.x[i];
    const cdy = this.y[j] - this.y[i];
    const maxDist = this.capBound[i] + this.capBound[j];
    const cd2 = cdx * cdx + cdy * cdy;
    if (cd2 >= maxDist * maxDist) return 0;

    const ih = this.capHalf[i];
    const jh = this.capHalf[j];

    const a0x = this.x[i] - this.dirX[i] * ih;
    const a0y = this.y[i] - this.dirY[i] * ih;
    const a1x = this.x[i] + this.dirX[i] * ih;
    const a1y = this.y[i] + this.dirY[i] * ih;

    const b0x = this.x[j] - this.dirX[j] * jh;
    const b0y = this.y[j] - this.dirY[j] * jh;
    const b1x = this.x[j] + this.dirX[j] * jh;
    const b1y = this.y[j] + this.dirY[j] * jh;

    const ux = a1x - a0x;
    const uy = a1y - a0y;
    const vx = b1x - b0x;
    const vy = b1y - b0y;
    const wx = a0x - b0x;
    const wy = a0y - b0y;

    const a = ux * ux + uy * uy;
    const b = ux * vx + uy * vy;
    const c = vx * vx + vy * vy;
    const d = ux * wx + uy * wy;
    const e = vx * wx + vy * wy;
    const denom = a * c - b * b;

    let sn;
    let sd = denom;
    let tn;
    let td = denom;

    if (denom < this.segmentEps) {
      sn = 0;
      sd = 1;
      tn = e;
      td = c;
    } else {
      sn = b * e - c * d;
      tn = a * e - b * d;

      if (sn < 0) {
        sn = 0;
        tn = e;
        td = c;
      } else if (sn > sd) {
        sn = sd;
        tn = e + b;
        td = c;
      }
    }

    if (tn < 0) {
      tn = 0;
      if (-d < 0) {
        sn = 0;
      } else if (-d > a) {
        sn = sd;
      } else {
        sn = -d;
        sd = a;
      }
    } else if (tn > td) {
      tn = td;
      if (-d + b < 0) {
        sn = 0;
      } else if (-d + b > a) {
        sn = sd;
      } else {
        sn = -d + b;
        sd = a;
      }
    }

    const sc = Math.abs(sn) < this.segmentEps ? 0 : sn / sd;
    const tc = Math.abs(tn) < this.segmentEps ? 0 : tn / td;

    const pax = a0x + sc * ux;
    const pay = a0y + sc * uy;
    const pbx = b0x + tc * vx;
    const pby = b0y + tc * vy;

    const dx = pbx - pax;
    const dy = pby - pay;
    const dist = Math.hypot(dx, dy);
    const minDist = this.capR[i] + this.capR[j];
    const overlap = minDist - dist;
    if (overlap <= 0) return 0;
    return overlap / Math.max(0.0001, minDist);
  }

  solveCollisions(passCount = this.collisionPasses) {
    for (let pass = 0; pass < passCount; pass++) {
      if (pass > 0) this.buildCollisionGrid();

      for (let ai = 0; ai < this.activeCount; ai++) {
        const i = this.activeIndices[ai];
        const cxi = this.cellX[i];
        const cyi = this.cellY[i];
        const iSleeping = this.sleeping[i] === 1;

        for (let oy = -this.neighborRange; oy <= this.neighborRange; oy++) {
          const cy = cyi + oy;
          if (cy < 0 || cy >= this.collisionRows) continue;
          const row = cy * this.collisionCols;

          for (let ox = -this.neighborRange; ox <= this.neighborRange; ox++) {
            const cx = cxi + ox;
            if (cx < 0 || cx >= this.collisionCols) continue;

            let j = this.collisionGridHead[row + cx];
            while (j !== -1) {
              if (j !== i) {
                if (this.sleeping[j]) {
                  if (!iSleeping) this.resolvePair(i, j);
                } else if (j > i) {
                  this.resolvePair(i, j);
                }
              }
              j = this.nextInCell[j];
            }
          }
        }

        this.resolveBoundary(i);
      }
    }

    // One final boundary clamp prevents post-collision pushes below the floor.
    for (let i = 0; i < this.particleCount; i++) {
      this.resolveBoundary(i);
    }
  }

  buildFluidGrid() {
    this.fluidOcc.fill(0);
    this.fluidMask.fill(0);
    this.boundaryMask.fill(0);

    const cellArea = this.fluidCellSize * this.fluidCellSize;
    for (let i = 0; i < this.particleCount; i++) {
      const cx = Math.max(0, Math.min(this.fluidCols - 1, ((this.x[i] / this.fluidCellSize) | 0) + 1));
      const cy = Math.max(0, Math.min(this.fluidRows - 1, ((this.y[i] / this.fluidCellSize) | 0) + 2));
      const idx = cy * this.fluidCols + cx;
      this.fluidCellOfParticle[i] = idx;

      const areaApprox = Math.PI * this.capBound[i] * this.capBound[i];
      this.fluidOcc[idx] += areaApprox / cellArea;
    }

    const cellCount = this.fluidCols * this.fluidRows;
    for (let idx = 0; idx < cellCount; idx++) {
      if (this.fluidOcc[idx] >= this.fluidThreshold) this.fluidMask[idx] = 1;
    }

    const cellSize = this.fluidCellSize;

    for (let cy = 1; cy < this.fluidRows - 1; cy++) {
      const row = cy * this.fluidCols;
      for (let cx = 1; cx < this.fluidCols - 1; cx++) {
        const idx = row + cx;
        if (!this.fluidMask[idx]) continue;

        let isBoundary = false;
        let nx = cx - 1;
        let ny = cy;
        let nidx = ny * this.fluidCols + nx;
        if (!this.fluidMask[nidx]) {
          let wx = (nx - 1) * cellSize;
          let wy = (ny - 2) * cellSize;
          if (!(wx < 0 || wx + cellSize > this.width || wy + cellSize > this.height)) {
            isBoundary = true;
          }
        }
        if (!isBoundary) {
          nx = cx + 1;
          ny = cy;
          nidx = ny * this.fluidCols + nx;
          if (!this.fluidMask[nidx]) {
            let wx = (nx - 1) * cellSize;
            let wy = (ny - 2) * cellSize;
            if (!(wx < 0 || wx + cellSize > this.width || wy + cellSize > this.height)) {
              isBoundary = true;
            }
          }
        }
        if (!isBoundary) {
          nx = cx;
          ny = cy - 1;
          nidx = ny * this.fluidCols + nx;
          if (!this.fluidMask[nidx]) {
            let wx = (nx - 1) * cellSize;
            let wy = (ny - 2) * cellSize;
            if (!(wx < 0 || wx + cellSize > this.width || wy + cellSize > this.height)) {
              isBoundary = true;
            }
          }
        }
        if (!isBoundary) {
          nx = cx;
          ny = cy + 1;
          nidx = ny * this.fluidCols + nx;
          if (!this.fluidMask[nidx]) {
            let wx = (nx - 1) * cellSize;
            let wy = (ny - 2) * cellSize;
            if (!(wx < 0 || wx + cellSize > this.width || wy + cellSize > this.height)) {
              isBoundary = true;
            }
          }
        }

        if (isBoundary) this.boundaryMask[idx] = 1;
      }
    }
  }

  updateSleepWake() {
    this.sleepingCount = 0;
    this.boundaryAwakeCount = 0;
    this.interiorSleepingCount = 0;

    const wakeRadius = this.mouseRadius * this.wakeCursorRadiusMul;
    const wakeRadiusSq = wakeRadius * wakeRadius;
    const allowAggressiveInteriorSleep = !this.mouse.active && this.particleCount >= this.targetCount;

    for (let i = 0; i < this.particleCount; i++) {
      const fluidCell = this.fluidCellOfParticle[i];
      let region = 0;
      if (this.fluidMask[fluidCell]) region = this.boundaryMask[fluidCell] ? 1 : 2;
      this.region[i] = region;

      let mouseWake = false;
      if (this.mouse.active) {
        const dx = this.x[i] - this.mouse.x;
        const dy = this.y[i] - this.mouse.y;
        mouseWake = dx * dx + dy * dy < wakeRadiusSq;
      }

      if (region !== 2 || mouseWake) {
        this.wakeParticle(i);
        if (region === 1) this.boundaryAwakeCount++;
        continue;
      }

      if (allowAggressiveInteriorSleep) {
        this.sleeping[i] = 1;
        this.sleepCounter[i] = this.interiorSleepFrames;
        this.px[i] = this.x[i];
        this.py[i] = this.y[i];
        this.vrot[i] = 0;
      } else {
        const vx = this.x[i] - this.px[i];
        const vy = this.y[i] - this.py[i];
        const speedSq = vx * vx + vy * vy;
        const spin = Math.abs(this.vrot[i]);
        const stableMotion =
          speedSq <= this.interiorSleepSpeedSq * 100000 &&
          spin <= Math.max(0.0001, this.interiorSleepSpin * 2000);

        if (!this.sleeping[i]) {
          if (stableMotion) {
            if (this.sleepCounter[i] < 65535) this.sleepCounter[i]++;
          } else {
            this.sleepCounter[i] = 0;
          }
        }
      }

      if (this.sleepCounter[i] >= this.interiorSleepFrames) {
        this.sleeping[i] = 1;
        this.px[i] = this.x[i];
        this.py[i] = this.y[i];
        this.vrot[i] = 0;
      }

      if (this.sleeping[i]) this.sleepingCount++;
      if (this.sleeping[i]) this.interiorSleepingCount++;
    }
  }

  step(dt = this.fixedDt) {
    this.spawnStep(dt);
    this.integrate(dt);
    this.buildCollisionGrid();
    this.collectActiveParticles();
    this.solveCollisions(this.collisionPasses);
    const shouldRefreshFluid =
      this.mouse.active ||
      this.particleCount < this.targetCount ||
      this.stepIndex % this.fluidUpdateInterval === 0;
    if (shouldRefreshFluid) {
      this.buildFluidGrid();
      this.updateSleepWake();
    }
    this.stepIndex++;
    this.mouse.vx *= 0.82;
    this.mouse.vy *= 0.82;
  }

  runSteps(count, dt = this.fixedDt) {
    for (let i = 0; i < count; i++) this.step(dt);
  }

  forEachPotentialPair(callback) {
    for (let i = 0; i < this.particleCount; i++) {
      const cxi = this.cellX[i];
      const cyi = this.cellY[i];

      for (let oy = -this.neighborRange; oy <= this.neighborRange; oy++) {
        const cy = cyi + oy;
        if (cy < 0 || cy >= this.collisionRows) continue;
        const row = cy * this.collisionCols;

        for (let ox = -this.neighborRange; ox <= this.neighborRange; ox++) {
          const cx = cxi + ox;
          if (cx < 0 || cx >= this.collisionCols) continue;

          let j = this.collisionGridHead[row + cx];
          while (j !== -1) {
            if (j > i) callback(i, j);
            j = this.nextInCell[j];
          }
        }
      }
    }
  }

  getState() {
    let avgY = 0;
    let kinetic = 0;
    let inBounds = 0;

    for (let i = 0; i < this.particleCount; i++) {
      avgY += this.y[i];
      const vx = this.x[i] - this.px[i];
      const vy = this.y[i] - this.py[i];
      kinetic += vx * vx + vy * vy;

      const eb = this.capBound[i];
      if (
        this.x[i] >= eb - 1e-6 &&
        this.x[i] <= this.width - eb + 1e-6 &&
        this.y[i] <= this.height - eb + 1e-6
      ) {
        inBounds++;
      }
    }

    const count = this.particleCount;
    return {
      count,
      targetCount: this.targetCount,
      planePopulation: Array.from(this.planePopulation),
      avgY: count > 0 ? avgY / count : 0,
      kinetic,
      inBounds,
      boundsRatio: count > 0 ? inBounds / count : 1,
      sleepingCount: this.sleepingCount,
      boundaryAwakeCount: this.boundaryAwakeCount,
      interiorSleepingCount: this.interiorSleepingCount,
    };
  }

  getSleepState() {
    const count = this.particleCount;
    let interiorCount = 0;
    let boundaryCount = 0;
    let airCount = 0;
    let awakeCount = 0;

    for (let i = 0; i < count; i++) {
      if (!this.sleeping[i]) awakeCount++;
      const region = this.region[i];
      if (region === 2) interiorCount++;
      else if (region === 1) boundaryCount++;
      else airCount++;
    }

    let fluidCells = 0;
    let boundaryCells = 0;
    for (let i = 0; i < this.fluidMask.length; i++) {
      if (this.fluidMask[i]) fluidCells++;
      if (this.boundaryMask[i]) boundaryCells++;
    }

    return {
      sleepingCount: this.sleepingCount,
      awakeCount,
      interiorCount,
      boundaryCount,
      airCount,
      interiorSleepingCount: this.interiorSleepingCount,
      boundaryAwakeCount: this.boundaryAwakeCount,
      cellStats: {
        fluidCells,
        boundaryCells,
        airCells: this.fluidMask.length - fluidCells,
      },
    };
  }

  getRenderState() {
    return {
      count: this.particleCount,
      targetCount: this.targetCount,
      width: this.width,
      height: this.height,
      planePopulation: this.planePopulation,
      planeAlpha: this.planeAlpha,
      x: this.x,
      y: this.y,
      r: this.r,
      depth: this.depth,
      plane: this.plane,
      dirX: this.dirX,
      dirY: this.dirY,
      axialCos: this.axialCos,
      axialSin: this.axialSin,
      tint: this.tint,
      sleeping: this.sleeping,
      region: this.region,
      fluidCellSize: this.fluidCellSize,
      fluidCols: this.fluidCols,
      fluidRows: this.fluidRows,
      fluidOcc: this.fluidOcc,
      fluidMask: this.fluidMask,
      boundaryMask: this.boundaryMask,
      fluidThreshold: this.fluidThreshold,
    };
  }
}


function percentile(sortedValues, p) {
  if (sortedValues.length === 0) return 0;
  const idx = Math.min(sortedValues.length - 1, Math.max(0, Math.floor(p * (sortedValues.length - 1))));
  return sortedValues[idx];
}

function rmsFromSquared(sumSq, count) {
  if (count === 0) return 0;
  return Math.sqrt(sumSq / count);
}

function computeJostlingMetrics(engine) {
  const count = engine.particleCount;
  const interiorSpeeds = [];
  const boundarySpeeds = [];
  const airSpeeds = [];

  let interiorSumSq = 0;
  let boundarySumSq = 0;
  let airSumSq = 0;

  for (let i = 0; i < count; i++) {
    const vx = engine.x[i] - engine.px[i];
    const vy = engine.y[i] - engine.py[i];
    const speedSq = vx * vx + vy * vy;
    const speed = Math.sqrt(speedSq);

    if (engine.region[i] === 2) {
      interiorSpeeds.push(speed);
      interiorSumSq += speedSq;
    } else if (engine.region[i] === 1) {
      boundarySpeeds.push(speed);
      boundarySumSq += speedSq;
    } else {
      airSpeeds.push(speed);
      airSumSq += speedSq;
    }
  }

  interiorSpeeds.sort((a, b) => a - b);
  boundarySpeeds.sort((a, b) => a - b);
  airSpeeds.sort((a, b) => a - b);

  return {
    interiorCount: interiorSpeeds.length,
    boundaryCount: boundarySpeeds.length,
    airCount: airSpeeds.length,
    interiorRmsSpeed: rmsFromSquared(interiorSumSq, interiorSpeeds.length),
    boundaryRmsSpeed: rmsFromSquared(boundarySumSq, boundarySpeeds.length),
    airRmsSpeed: rmsFromSquared(airSumSq, airSpeeds.length),
    interiorP95Speed: percentile(interiorSpeeds, 0.95),
    boundaryP95Speed: percentile(boundarySpeeds, 0.95),
    airP95Speed: percentile(airSpeeds, 0.95),
  };
}

function computeCompressionMetrics(engine, options = {}) {
  const maxSamples = options.maxSamples ?? 12000;
  const values = [];
  const threshold = Math.max(0.0001, engine.fluidThreshold);

  for (let i = 0; i < engine.fluidOcc.length; i++) {
    if (!engine.fluidMask[i]) continue;
    // Interior fluid compression is what matters for packed stability.
    if (engine.boundaryMask[i]) continue;
    values.push(engine.fluidOcc[i] / threshold);
    if (values.length >= maxSamples) break;
  }

  if (values.length === 0) {
    for (let i = 0; i < engine.fluidOcc.length; i++) {
      if (!engine.fluidMask[i]) continue;
      values.push(engine.fluidOcc[i] / threshold);
      if (values.length >= maxSamples) break;
    }
  }

  values.sort((a, b) => a - b);

  let sum = 0;
  for (let i = 0; i < values.length; i++) sum += values[i];

  return {
    sampledCellCount: values.length,
    meanCompression: values.length > 0 ? sum / values.length : 0,
    p95Compression: percentile(values, 0.95),
    maxCompression: values.length > 0 ? values[values.length - 1] : 0,
  };
}

function summarizePileMetrics(engine, options = {}) {
  const jostling = computeJostlingMetrics(engine);
  const compression = computeCompressionMetrics(engine, options);
  const sleep = engine.getSleepState();

  return {
    jostling,
    compression,
    sleep,
  };
}


window.BananaSim = {
  BananaPileEngine,
  computeJostlingMetrics,
  computeCompressionMetrics,
  summarizePileMetrics,
};
})();
